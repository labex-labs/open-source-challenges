# Special Variables in Shell Scripting

## Introduction

In this lab, you will learn about special variables in shell scripting. These variables provide essential information about the script execution environment, such as command-line arguments, script name, and process ID. Understanding these variables will help you write more flexible and powerful shell scripts.

## Steps

### Step 1: Creating Your First Script

Let's start by creating a simple shell script to demonstrate the use of special variables.

1. Open your terminal in the WebIDE. You should see a command prompt waiting for your input.

2. Navigate to the project directory:

```bash
cd ~/project
```

This command changes your current directory to `~/project`, which is your default working directory for this lab.

3. Create a new file named `special_vars.sh` using the following command:

```bash
touch special_vars.sh
```

The `touch` command creates an empty file if it doesn't exist, or updates its timestamp if it does.

4. Open the file in the WebIDE editor. You can do this by clicking on the file name in the file explorer on the left side of your screen.

5. Add the following content to the file:

```bash
#!/bin/bash

echo "Script Name: $0"
echo "First Argument: $1"
echo "Second Argument: $2"
echo "All Arguments: $@"
echo "Number of Arguments: $#"
echo "Process ID: $$"
```

Let's break down what each line does:

- `#!/bin/bash`: This is called a shebang. It tells the system to use bash to interpret this script.
- `$0`: This special variable holds the name of the script.
- `$1` and `$2`: These represent the first and second command-line arguments respectively.
- `$@`: This represents all the command-line arguments passed to the script.
- `$#`: This gives the count of command-line arguments.
- `$$`: This provides the process ID of the current shell.

6. Save the file after adding the content.

7. Make the script executable by running the following command in your terminal:

```bash
chmod +x special_vars.sh
```

The `chmod` command changes the permissions of a file. The `+x` option adds execute permission, allowing you to run the script.

#### Verification

```yaml
- name: Verify script creation
  script: |
    #!/bin/bash
    if [[ -f ~/project/special_vars.sh ]]; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Make sure you have created the file 'special_vars.sh' in the ~/project directory.

- name: Verify script content
  script: |
    #!/bin/bash
    if grep -q "Script Name: \$0" ~/project/special_vars.sh; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Ensure that your script includes the line to print the script name.

- name: Verify script permissions
  script: |
    #!/bin/bash
    if [[ -x ~/project/special_vars.sh ]]; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Make sure you have made the script executable using the chmod command.
```

### Step 2: Running the Script with Arguments

Now that we have created our script, let's run it with different arguments to see how the special variables behave.

1. Run the script without any arguments:

```bash
./special_vars.sh
```

The `./` before the script name tells the shell to look for the script in the current directory.

You should see output similar to this:

```
Script Name: ./special_vars.sh
First Argument:
Second Argument:
All Arguments:
Number of Arguments: 0
Process ID: 1234
```

Notice that the first and second arguments are empty, and the number of arguments is 0 since we didn't provide any.

2. Now, run the script with some arguments:

```bash
./special_vars.sh hello world
```

The output should look like this:

```
Script Name: ./special_vars.sh
First Argument: hello
Second Argument: world
All Arguments: hello world
Number of Arguments: 2
Process ID: 1235
```

Here's what changed:

- `$1` now contains "hello"
- `$2` now contains "world"
- `$@` shows all arguments: "hello world"
- `$#` shows 2, because we provided two arguments

The Process ID (`$$`) might be different each time you run the script, as it's assigned by the operating system.

#### Verification

```yaml
- name: Verify script execution without arguments
  script: |
    #!/bin/bash
    output=$(~/project/special_vars.sh)
    if echo "$output" | grep -q "Number of Arguments: 0"; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Make sure you can run the script without any arguments.

- name: Verify script execution with arguments
  script: |
    #!/bin/bash
    output=$(~/project/special_vars.sh hello world)
    if echo "$output" | grep -q "First Argument: hello"; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Ensure that you can run the script with arguments and that it correctly displays the provided arguments.
```

### Step 3: Understanding $? and $

Two other important special variables are `$?` and `$!`. Let's create a new script to demonstrate their use.

1. Create a new file named `exit_status.sh`:

```bash
touch ~/project/exit_status.sh
```

2. Open the file in the WebIDE editor and add the following content:

```bash
#!/bin/bash

echo "Running a successful command:"
ls /home
echo "Exit status: $?"

echo "Running a command that will fail:"
ls /nonexistent_directory
echo "Exit status: $?"

echo "Running a background process:"
sleep 10 &
echo "Process ID of last background command: $!"
```

Let's break down this script:

- `$?` gives the exit status of the last executed command. 0 typically means success, while non-zero values indicate various error conditions.
- `$!` gives the process ID of the last background command.
- The `&` at the end of a command runs it in the background.

3. Save the file and make it executable:

```bash
chmod +x ~/project/exit_status.sh
```

4. Run the script:

```bash
./exit_status.sh
```

You should see output similar to this:

```
Running a successful command:
labex
Exit status: 0
Running a command that will fail:
ls: cannot access '/nonexistent_directory': No such file or directory
Exit status: 2
Running a background process:
Process ID of last background command: 1236
```

Notice:

- The first `ls` command succeeds, so `$?` is 0.
- The second `ls` command fails (because the directory doesn't exist), so `$?` is 2 (a non-zero value indicating an error).
- The `sleep` command runs in the background, and `$!` gives its process ID.

#### Verification

```yaml
- name: Verify exit_status.sh creation
  script: |
    #!/bin/bash
    if [[ -f ~/project/exit_status.sh ]]; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Make sure you have created the file 'exit_status.sh' in the ~/project directory.

- name: Verify exit_status.sh content
  script: |
    #!/bin/bash
    if grep -q "Exit status: \$?" ~/project/exit_status.sh; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Ensure that your script includes lines to demonstrate the use of $?.

- name: Verify exit_status.sh execution
  script: |
    #!/bin/bash
    output=$(~/project/exit_status.sh)
    if echo "$output" | grep -q "Exit status: 0"; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Make sure you can run the exit_status.sh script and that it produces the expected output.
```

### Step 4: Using Special Variables in Functions

Special variables can also be used within functions. Let's create a script to demonstrate this.

1. Create a new file named `function_vars.sh`:

```bash
touch ~/project/function_vars.sh
```

2. Open the file in the WebIDE editor and add the following content:

```bash
#!/bin/bash

function print_args {
  echo "Function Name: $0"
  echo "First Argument: $1"
  echo "Second Argument: $2"
  echo "All Arguments: $@"
  echo "Number of Arguments: $#"
}

echo "Calling function with two arguments:"
print_args hello world

echo "Calling function with four arguments:"
print_args one two three four
```

This script defines a function `print_args` that uses special variables. Then it calls this function twice with different numbers of arguments.

3. Save the file and make it executable:

```bash
chmod +x ~/project/function_vars.sh
```

4. Run the script:

```bash
./function_vars.sh
```

You should see output similar to this:

```
Calling function with two arguments:
Function Name: ./function_vars.sh
First Argument: hello
Second Argument: world
All Arguments: hello world
Number of Arguments: 2
Calling function with four arguments:
Function Name: ./function_vars.sh
First Argument: one
Second Argument: two
All Arguments: one two three four
Number of Arguments: 4
```

Notice that:

- `$0` still refers to the script name, not the function name.
- `$1`, `$2`, `$@`, and `$#` work for function arguments just like they do for script arguments.
- The values of these variables change each time the function is called with different arguments.

#### Verification

```yaml
- name: Verify function_vars.sh creation
  script: |
    #!/bin/bash
    if [[ -f ~/project/function_vars.sh ]]; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Make sure you have created the file 'function_vars.sh' in the ~/project directory.

- name: Verify function_vars.sh content
  script: |
    #!/bin/bash
    if grep -q "function print_args" ~/project/function_vars.sh; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Ensure that your script includes a function named 'print_args'.

- name: Verify function_vars.sh execution
  script: |
    #!/bin/bash
    output=$(~/project/function_vars.sh)
    if echo "$output" | grep -q "Number of Arguments: 4"; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Make sure you can run the function_vars.sh script and that it produces the expected output.
```

### Step 5: Understanding the Difference Between $@ and $\*

The special variables `$@` and `$*` are both used to represent all command-line arguments, but they behave differently when enclosed in double quotes. Let's create a script to demonstrate this difference.

1. Create a new file named `at_vs_star.sh`:

```bash
touch ~/project/at_vs_star.sh
```

2. Open the file in the WebIDE editor and add the following content:

```bash
#!/bin/bash

echo "Using \$@:"
for arg in "$@"; do
  echo "Argument: $arg"
done

echo "Using \$*:"
for arg in "$*"; do
  echo "Argument: $arg"
done
```

This script demonstrates the difference between `$@` and `$*` when used in a loop.

3. Save the file and make it executable:

```bash
chmod +x ~/project/at_vs_star.sh
```

4. Run the script with multiple arguments, including some with spaces:

```bash
./at_vs_star.sh "arg with spaces" another_arg "third arg"
```

You should see output similar to this:

```
Using $@:
Argument: arg with spaces
Argument: another_arg
Argument: third arg
Using $*:
Argument: arg with spaces another_arg third arg
```

Here's what's happening:

- With `"$@"`, each argument is treated as a separate entity. Arguments with spaces are preserved as single units.
- With `"$*"`, all arguments are combined into a single string, separated by the first character of the IFS (Internal Field Separator) variable, which is usually a space.

This difference is crucial when you need to process arguments that might contain spaces or other special characters.

#### Verification

```yaml
- name: Verify at_vs_star.sh creation
  script: |
    #!/bin/bash
    if [[ -f ~/project/at_vs_star.sh ]]; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Make sure you have created the file 'at_vs_star.sh' in the ~/project directory.

- name: Verify at_vs_star.sh content
  script: |
    #!/bin/bash
    if grep -q "for arg in \"\$@\"" ~/project/at_vs_star.sh; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Ensure that your script includes a loop demonstrating the use of $@.

- name: Verify at_vs_star.sh execution
  script: |
    #!/bin/bash
    output=$(~/project/at_vs_star.sh "arg with spaces" another_arg "third arg")
    if echo "$output" | grep -q "Argument: arg with spaces"; then
      exit 0
    else
      exit 1
    fi
  hint: |
    Make sure you can run the at_vs_star.sh script with multiple arguments and that it produces the expected output.
```

## Summary

In this lab, you have learned about special variables in shell scripting and how to use them effectively. You have created scripts that demonstrate the usage of various special variables such as `$0`, `$1`, `$@`, `$#`, `$$`, `$?`, and `$!`. You have also explored how these variables behave in different contexts, including within functions and when handling command-line arguments.

Key takeaways:

1. `$0`, `$1`, `$2`, etc. represent the script name and command-line arguments.
2. `$@` and `$#` allow you to work with all arguments and count them.
3. `$$` gives you the current process ID, useful for creating unique temporary files.
4. `$?` helps you check if the previous command was successful.
5. `$!` gives you the PID of the last background process, useful for job control.
6. `$@` and `$*` behave differently when quoted, which is important when handling arguments with spaces.

Understanding these special variables is crucial for writing more advanced and flexible shell scripts. They allow you to create scripts that can adapt to different inputs and provide valuable information about the script's execution environment.

As you continue to practice and experiment with shell scripting, you'll find many more ways to leverage these special variables in your work. Remember to consult the bash manual (`man bash`) for more detailed information on these and other special variables.

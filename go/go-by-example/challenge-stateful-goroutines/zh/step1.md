# 有状态的 Goroutine

在并发编程中，同步对共享状态的访问以避免竞态条件和数据损坏至关重要。此挑战呈现了一种场景：单个 goroutine 拥有状态，而其他 goroutine 发送消息来读取或写入该状态。

## 要求

- 使用通道向拥有状态的 goroutine 发出读取和写入请求。
- 使用 `readOp` 和 `writeOp` 结构体封装请求和响应。
- 使用映射来存储状态。
- 使用 `resp` 通道指示成功并返回值。
- 使用 `atomic` 包统计读取和写入操作。
- 使用 `time` 包在操作之间添加延迟。

## 示例

```sh
# 运行我们的程序表明，基于 goroutine 的
# 状态管理示例总共完成了约 80,000 次
# 操作。
$ go run stateful-goroutines.go
readOps: 71708
writeOps: 7177

# 对于这种特定情况，基于 goroutine 的方法
# 比基于互斥锁的方法稍微复杂一些。不过，
# 在某些情况下它可能会很有用，例如
# 当你涉及其他通道时，或者当管理多个
# 这样的互斥锁容易出错时。你应该使用
# 感觉最自然的方法，特别是在理解程序
# 的正确性方面。
```

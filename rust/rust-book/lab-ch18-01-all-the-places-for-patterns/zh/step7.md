# 函数参数

函数参数也可以是模式。清单 18-6 中的代码声明了一个名为 `foo` 的函数，它接受一个名为 `x` 的 `i32` 类型参数，现在你应该对这段代码很熟悉了。

```rust
fn foo(x: i32) {
    // 代码写在这里
}
```

清单 18-6：在参数中使用模式的函数签名

`x` 部分就是一个模式！就像我们在 `let` 中做的那样，我们可以将函数参数中的元组与模式进行匹配。清单 18-7 在将元组传递给函数时对其值进行了拆分。

文件名：`src/main.rs`

```rust
fn print_coordinates(&(x, y): &(i32, i32)) {
    println!("Current location: ({x}, {y})");
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```

清单 18-7：一个参数解构元组的函数

这段代码打印出 `Current location: (3, 5)`。值 `&(3, 5)` 与模式 `&(x, y)` 匹配，所以 `x` 的值是 `3`，`y` 的值是 `5`。

我们也可以在闭包参数列表中以与函数参数列表相同的方式使用模式，因为正如第 13 章所讨论的，闭包与函数类似。

至此，你已经看到了几种使用模式的方法，但模式在我们可以使用它们的每个地方的工作方式并不相同。在某些地方，模式必须是不可反驳的；在其他情况下，它们可以是可反驳的。接下来我们将讨论这两个概念。

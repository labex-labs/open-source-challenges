# 创建用于验证的自定义类型

让我们进一步运用 Rust 的类型系统来确保我们拥有一个有效值的理念，看看如何创建一个用于验证的自定义类型。回忆一下第 2 章中的猜数字游戏，在那个游戏中，我们的代码要求用户猜一个 1 到 100 之间的数字。在将用户的猜测与我们的秘密数字进行比较之前，我们从未验证过用户的猜测是否在这个范围内；我们只验证了猜测是否为正数。在这种情况下，后果并不是很严重：我们输出的“太高”或“太低”仍然是正确的。但是，如果能引导用户进行有效的猜测，并在用户猜测超出范围与用户输入字母等情况时表现出不同的行为，那将是一个很有用的改进。

一种实现方法是将猜测解析为 `i32` 而不仅仅是 `u32`，以允许可能的负数，然后添加一个检查数字是否在范围内的操作，如下所示：

文件名：`src/main.rs`

```rust
loop {
    --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) => num,
        Err(_) => continue,
    };

    if guess < 1 || guess > 100 {
        println!("秘密数字将在 1 到 100 之间。");
        continue;
    }

    match guess.cmp(&secret_number) {
        --snip--
}
```

`if` 表达式检查我们的值是否超出范围，告诉用户问题所在，并调用 `continue` 开始循环的下一次迭代并要求再次猜测。在 `if` 表达式之后，我们可以继续进行 `guess` 和秘密数字之间的比较，因为我们知道 `guess` 在 1 到 100 之间。

然而，这并不是一个理想的解决方案：如果程序绝对必须只对 1 到 100 之间的值进行操作，并且有许多函数都有这个要求，那么在每个函数中都进行这样的检查会很繁琐（并且可能会影响性能）。

相反，我们可以创建一个新类型，并将验证放在一个函数中，以创建该类型的实例，而不是在各处重复验证。这样，函数在其签名中使用新类型并自信地使用它们接收到的值就是安全的。清单 9-13 展示了一种定义 `Guess` 类型的方法，只有当 `new` 函数接收到一个 1 到 100 之间的值时，才会创建 `Guess` 的实例。

文件名：`src/lib.rs`

```rust
1 pub struct Guess {
    value: i32,
}

impl Guess {
  2 pub fn new(value: i32) -> Guess {
      3 if value < 1 || value > 100 {
          4 panic!(
                "猜测值必须在 1 到 100 之间，得到的是 {}.",
                value
            );
        }

      5 Guess { value }
    }

  6 pub fn value(&self) -> i32 {
        self.value
    }
}
```

清单 9-13：一个只接受 1 到 100 之间值的 `Guess` 类型

首先，我们定义一个名为 `Guess` 的结构体，它有一个名为 `value` 的字段，用于存储一个 `i32` \[1\]。这就是数字将被存储的地方。

然后，我们在 `Guess` 上实现一个关联函数 `new`，用于创建 `Guess` 值的实例 \[2\]。`new` 函数被定义为有一个名为 `value` 的 `i32` 类型参数，并返回一个 `Guess`。`new` 函数体中的代码会测试 `value`，以确保它在 1 到 100 之间 \[3\]。如果 `value` 没有通过这个测试，我们就进行一次 `panic!` 调用 \[4\]，这将提醒编写调用代码的程序员他们有一个需要修复的错误，因为创建一个 `value` 超出此范围的 `Guess` 将违反 `Guess::new` 所依赖的契约。`Guess::new` 可能会发生恐慌的情况应该在其面向公众的 API 文档中进行讨论；我们将在第 14 章中介绍在你创建的 API 文档中表明可能发生 `panic!` 的文档约定。如果 `value` 通过了测试，我们就创建一个新的 `Guess`，将其 `value` 字段设置为 `value` 参数，并返回这个 `Guess` \[5\]。

接下来，我们实现一个名为 `value` 的方法，它借用 `self`，没有任何其他参数，并返回一个 `i32` \[6\]。这种方法有时被称为“获取器”，因为它的目的是从其字段中获取一些数据并返回它。这个公共方法是必要的，因为 `Guess` 结构体的 `value` 字段是私有的。`value` 字段为私有很重要，这样使用 `Guess` 结构体的代码就不允许直接设置 `value`：模块外部的代码必须使用 `Guess::new` 函数来创建 `Guess` 的实例，从而确保不可能有一个 `Guess` 的 `value` 没有经过 `Guess::new` 函数中的条件检查。

然后，一个函数如果其参数或返回值只在 1 到 100 之间的数字，那么它可以在其签名中声明它接受或返回一个 `Guess` 而不是 `i32`，并且在其函数体中不需要进行任何额外的检查。

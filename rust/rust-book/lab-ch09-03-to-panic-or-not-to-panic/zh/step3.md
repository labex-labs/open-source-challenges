# 你比编译器掌握更多信息的情况

当你有其他逻辑确保 `Result` 将具有 `Ok` 值，但编译器无法理解该逻辑时，调用 `unwrap` 或 `expect` 也是合适的。你仍然需要处理一个 `Result` 值：无论你调用的是什么操作，通常仍然有可能失败，即使在你的特定情况下从逻辑上讲是不可能的。如果你可以通过手动检查代码确保永远不会有 `Err` 变体，那么调用 `unwrap` 是完全可以接受的，甚至更好的做法是在 `expect` 的文本中记录你认为永远不会有 `Err` 变体的原因。下面是一个例子：

```rust
use std::net::IpAddr;

let home: IpAddr = "127.0.0.1"
 .parse()
 .expect("硬编码的 IP 地址应该是有效的");
```

我们通过解析一个硬编码的字符串来创建一个 `IpAddr` 实例。我们可以看到 `127.0.0.1` 是一个有效的 IP 地址，所以在这里使用 `expect` 是可以接受的。然而，有一个硬编码的有效字符串并不会改变 `parse` 方法的返回类型：我们仍然会得到一个 `Result` 值，并且编译器仍然会要求我们像处理 `Err` 变体有可能出现那样来处理 `Result`，因为编译器不够智能，无法看出这个字符串总是一个有效的 IP 地址。如果 IP 地址字符串来自用户而不是硬编码到程序中，因此确实有可能失败，那么我们肯定会希望以更健壮的方式处理 `Result`。提到这个 IP 地址是硬编码的这个假设，如果将来我们需要从其他来源获取 IP 地址，会促使我们将 `expect` 改为更好的错误处理代码。

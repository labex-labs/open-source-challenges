# 错误处理指南

当你的代码可能最终处于不良状态时，最好让代码发生恐慌。在这种情况下，“不良状态”是指某些假设、保证、约定或不变量被打破，例如当无效值、矛盾值或缺失值被传递给你的代码时，再加上以下一种或多种情况：

- 不良状态是意外情况，而不是偶尔可能发生的情况，比如用户输入错误格式的数据。
- 在此之后你的代码需要依赖于不处于这种不良状态，而不是在每一步都检查问题。
- 没有好的方法在你使用的类型中编码此信息。我们将在“将状态和行为编码为类型”中详细说明我们的意思。

如果有人调用你的代码并传入不合理的值，如果你可以的话，最好返回一个错误，以便库的用户可以决定在这种情况下他们想做什么。然而，在继续可能不安全或有害的情况下，最好的选择可能是调用 `panic!`，并提醒使用你的库的人注意他们代码中的错误，以便他们可以在开发过程中修复它。同样，如果你调用无法控制的外部代码，而它返回一个你无法修复的无效状态，`panic!` 通常也是合适的。

然而，当预期会失败时，返回一个 `Result` 比调用 `panic!` 更合适。示例包括解析器接收到格式错误的数据，或者 HTTP 请求返回一个表示你已达到速率限制的状态。在这些情况下，返回一个 `Result` 表示失败是一种预期的可能性，调用代码必须决定如何处理。

当你的代码执行一个操作，如果使用无效值调用可能会使用户面临风险时，你的代码应该首先验证值是否有效，如果值无效则发生恐慌。这主要是出于安全原因：尝试对无效数据进行操作可能会使你的代码暴露于漏洞。这就是为什么如果你尝试进行越界内存访问，标准库会调用 `panic!` 的主要原因：试图访问不属于当前数据结构的内存是一个常见的安全问题。函数通常有“契约”：只有当输入满足特定要求时，它们的行为才得到保证。当契约被违反时发生恐慌是有意义的，因为契约违反总是表明调用方存在错误，并且这不是一种你希望调用代码必须显式处理的错误类型。实际上，调用代码没有合理的方法来恢复；调用的程序员需要修复代码。函数的契约，特别是当违反契约将导致恐慌时，应该在函数的 API 文档中进行解释。

然而，在所有函数中进行大量的错误检查会很冗长且烦人。幸运的是，你可以使用 Rust 的类型系统（以及因此由编译器完成的类型检查）为你进行许多检查。如果你的函数有一个特定类型作为参数，你可以在知道编译器已经确保你有一个有效值的情况下继续你的代码逻辑。例如，如果你有一个类型而不是 `Option`，你的程序期望有“某个东西”而不是“没有东西”。然后你的代码不必处理 `Some` 和 `None` 变体的两种情况：它只会有一种肯定有值的情况。试图将没有值传递给你的函数的代码甚至不会编译，所以你的函数不必在运行时检查那种情况。另一个例子是使用无符号整数类型，如 `u32`，它确保参数永远不会为负。

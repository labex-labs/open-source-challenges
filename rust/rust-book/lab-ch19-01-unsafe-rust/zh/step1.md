# 不安全的 Rust

到目前为止我们讨论的所有代码在编译时都有 Rust 的内存安全保证。然而，Rust 内部隐藏着另一种语言，它并不强制执行这些内存安全保证：它被称为*不安全的 Rust*，其工作方式与普通 Rust 类似，但赋予了我们额外的强大功能。

不安全的 Rust 之所以存在，是因为从本质上讲，静态分析是保守的。当编译器试图确定代码是否符合保证时，拒绝一些有效的程序比接受一些无效的程序对它来说更好。虽然代码*可能*是没问题的，但如果 Rust 编译器没有足够的信息来确定，它就会拒绝该代码。在这些情况下，你可以使用不安全代码来告诉编译器，“相信我，我知道自己在做什么”。不过要注意，使用不安全的 Rust 你要自行承担风险：如果你不正确地使用不安全代码，可能会由于内存不安全而出现问题，比如空指针解引用。

Rust 有一个不安全的变体的另一个原因是底层计算机硬件本身就是不安全的。如果 Rust 不允许你进行不安全操作，你就无法完成某些任务。Rust 需要允许你进行底层系统编程，比如直接与操作系统交互，甚至编写自己的操作系统。进行底层系统编程是该语言的目标之一。让我们来探索一下用不安全的 Rust 我们能做什么以及如何去做。

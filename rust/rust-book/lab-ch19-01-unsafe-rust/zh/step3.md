# 解引用裸指针

在“悬垂引用”一节中，我们提到编译器会确保引用始终有效。不安全的 Rust 有两种新类型，称为*裸指针*，它们类似于引用。与引用一样，裸指针可以是不可变的或可变的，分别写为 `*const T` 和 `*mut T`。星号不是解引用运算符；它是类型名称的一部分。在裸指针的上下文中，*不可变*意味着指针在被解引用后不能直接重新赋值。

与引用和智能指针不同，裸指针：

- 可以通过拥有不可变和可变指针或指向同一位置的多个可变指针来忽略借用规则
- 不能保证指向有效的内存
- 允许为空
- 不执行任何自动清理

通过选择不使用 Rust 来强制执行这些保证，你可以放弃有保证的安全性，以换取更高的性能，或者获得与 Rust 的保证不适用的其他语言或硬件进行交互的能力。

清单 19-1 展示了如何从引用创建不可变和可变的裸指针。

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;
```

清单 19-1：从引用创建裸指针

注意，我们在这段代码中没有包含 `unsafe` 关键字。我们可以在安全代码中创建裸指针；正如你稍后会看到的，我们只是不能在不安全块之外解引用裸指针。

我们通过使用 `as` 将不可变和可变引用转换为它们相应的裸指针类型来创建裸指针。因为我们是直接从保证有效的引用创建它们的，所以我们知道这些特定的裸指针是有效的，但对于任何裸指针我们都不能做这样的假设。

为了说明这一点，接下来我们将创建一个我们不能确定其有效性的裸指针。清单 19-2 展示了如何创建一个指向内存中任意位置的裸指针。尝试使用任意内存是未定义行为：该地址可能有数据，也可能没有，编译器可能会优化代码以至于没有内存访问，或者程序可能会因段错误而终止。通常，没有什么好理由编写这样的代码，但这是有可能的。

```rust
let address = 0x012345usize;
let r = address as *const i32;
```

清单 19-2：创建一个指向任意内存地址的裸指针

回想一下，我们可以在安全代码中创建裸指针，但我们不能*解引用*裸指针并读取其指向的数据。在清单 19-3 中，我们在一个需要 `unsafe` 块的裸指针上使用了解引用运算符 `*`。

```rust
let mut num = 5;

let r1 = &num as *const i32;
let r2 = &mut num as *mut i32;

unsafe {
    println!("r1 is: {}", *r1);
    println!("r2 is: {}", *r2);
}
```

清单 19-3：在 `unsafe` 块内解引用裸指针

创建一个指针不会造成危害；只有当我们尝试访问它所指向的值时，我们才可能最终处理一个无效值。

还要注意，在清单 19-1 和 19-3 中，我们创建了都指向存储 `num` 的同一内存位置的 `*const i32` 和 `*mut i32` 裸指针。如果我们尝试为 `num` 创建一个不可变引用和一个可变引用，代码将无法编译，因为 Rust 的所有权规则不允许在有任何不可变引用的同时存在可变引用。对于裸指针，我们可以创建一个指向同一位置的可变指针和一个不可变指针，并通过可变指针更改数据，这可能会导致数据竞争。小心！

有了所有这些危险，你为什么还要使用裸指针呢？一个主要用例是在与 C 代码交互时，正如你将在“调用不安全的函数或方法”中看到的。另一种情况是在构建借用检查器不理解的安全抽象时。我们将介绍不安全函数，然后看一个使用不安全代码的安全抽象的示例。

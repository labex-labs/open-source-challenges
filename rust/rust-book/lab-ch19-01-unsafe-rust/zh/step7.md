# 访问或修改可变静态变量

在本书中，我们尚未讨论全局变量，Rust 确实支持全局变量，但它们可能会与 Rust 的所有权规则产生问题。如果两个线程访问同一个可变全局变量，可能会导致数据竞争。

在 Rust 中，全局变量被称为*静态*变量。清单 19-9 展示了一个静态变量的声明和使用示例，其值为一个字符串切片。

文件名：`src/main.rs`

```rust
static HELLO_WORLD: &str = "Hello, world!";

fn main() {
    println!("value is: {HELLO_WORLD}");
}
```

清单 19-9：定义和使用不可变静态变量

静态变量类似于我们在“常量”中讨论过的常量。按照惯例，静态变量的名称采用`SCREAMING_SNAKE_CASE`。静态变量只能存储具有`'static`生命周期的引用，这意味着 Rust 编译器可以推断出生命周期，我们无需显式标注它。访问不可变静态变量是安全的。

常量和不可变静态变量之间的一个细微差别是，静态变量中的值在内存中有一个固定的地址。使用该值将始终访问相同的数据。另一方面，常量在每次使用时允许复制其数据。另一个区别是静态变量可以是可变的。访问和修改可变静态变量是*不安全的*。清单 19-10 展示了如何声明、访问和修改一个名为`COUNTER`的可变静态变量。

文件名：`src/main.rs`

```rust
static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!("COUNTER: {COUNTER}");
    }
}
```

清单 19-10：读取或写入可变静态变量是不安全的。

与常规变量一样，我们使用`mut`关键字指定可变性。任何读取或写入`COUNTER`的代码都必须在一个`unsafe`块内。这段代码可以编译并按预期打印出`COUNTER: 3`，因为它是单线程的。让多个线程访问`COUNTER`可能会导致数据竞争。

对于全局可访问的可变数据，很难确保不存在数据竞争，这就是为什么 Rust 认为可变静态变量是不安全的。只要有可能，最好使用我们在第 16 章中讨论过的并发技术和线程安全的智能指针，这样编译器就能检查不同线程对数据的访问是否安全。

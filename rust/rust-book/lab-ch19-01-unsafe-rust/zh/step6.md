# 使用 `extern` 函数调用外部代码

有时你的 Rust 代码可能需要与用其他语言编写的代码进行交互。为此，Rust 有 `extern` 关键字，它有助于创建和使用*外部函数接口*（_FFI_），这是一种编程语言定义函数并使另一种（外部）编程语言能够调用这些函数的方式。

清单 19-8 展示了如何与 C 标准库中的 `abs` 函数建立集成。在 `extern` 块中声明的函数从 Rust 代码中调用时总是不安全的。原因是其他语言不会强制执行 Rust 的规则和保证，而 Rust 无法检查它们，所以确保安全性的责任落在程序员身上。

文件名：`src/main.rs`

```rust
extern "C" {
    fn abs(input: i32) -> i32;
}

fn main() {
    unsafe {
        println!(
            "Absolute value of -3 according to C: {}",
            abs(-3)
        );
    }
}
```

清单 19-8：声明并调用在另一种语言中定义的 `extern` 函数

在 `extern "C"` 块中，我们列出了想要调用的来自另一种语言的外部函数的名称和签名。`"C"` 部分定义了外部函数使用的*应用二进制接口*（_ABI_）：ABI 定义了在汇编级别如何调用该函数。`"C"` ABI 是最常见的，并且遵循 C 编程语言的 ABI。

> **从其他语言调用 Rust 函数**
>
> 我们也可以使用 `extern` 创建一个接口，允许其他语言调用 Rust 函数。不是创建一个完整的 `extern` 块，而是在相关函数的 `fn` 关键字之前添加 `extern` 关键字并指定要使用的 ABI。我们还需要添加 `#[no_mangle]` 注释，以告诉 Rust 编译器不要混淆此函数的名称。*名称混淆*是指编译器将我们给函数的名称更改为另一个包含更多信息的名称，以便编译过程的其他部分使用，但不太易于人类阅读。每种编程语言编译器混淆名称的方式略有不同，因此为了使 Rust 函数能够被其他语言命名，我们必须禁用 Rust 编译器的名称混淆。
>
> 在以下示例中，在将 `call_from_c` 函数编译为共享库并从 C 链接之后，我们使其可以从 C 代码中访问：
>
>     #[no_mangle]
>     pub extern "C" fn call_from_c() {
>         println!("Just called a Rust function from C!");
>     }
>
> 这种 `extern` 的用法不需要 `unsafe`。

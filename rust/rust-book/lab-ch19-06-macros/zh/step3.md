# 使用 `macro_rules!` 的声明式宏进行通用元编程

Rust 中使用最广泛的宏形式是**声明式宏**。这些宏有时也被称为“示例宏”、“`macro_rules!` 宏”或简称为“宏”。从核心上来说，声明式宏允许你编写类似于 Rust `match` 表达式的东西。如第 6 章所述，`match` 表达式是一种控制结构，它接受一个表达式，将表达式的结果值与模式进行比较，然后运行与匹配模式相关联的代码。宏也会将一个值与和特定代码相关联的模式进行比较：在这种情况下，值是传递给宏的字面 Rust 源代码；模式与该源代码的结构进行比较；当匹配时，与每个模式相关联的代码会替换传递给宏的代码。这一切都在编译期间发生。

要定义一个宏，你可以使用 `macro_rules!` 结构。让我们通过查看 `vec!` 宏的定义方式来探索如何使用 `macro_rules!`。第 8 章介绍了我们如何使用 `vec!` 宏来创建一个包含特定值的新向量。例如，以下宏创建一个包含三个整数的新向量：

```rust
let v: Vec<u32> = vec![1, 2, 3];
```

我们也可以使用 `vec!` 宏来创建一个包含两个整数的向量或一个包含五个字符串切片的向量。我们无法使用函数来完成相同的操作，因为我们事先不知道值的数量或类型。

清单 19 - 28 展示了 `vec!` 宏的一个稍微简化的定义。

文件名：`src/lib.rs`

```rust
1 #[macro_export]
2 macro_rules! vec {
  3 ( $( $x:expr ),* ) => {
        {
            let mut temp_vec = Vec::new();
          4 $(
              5 temp_vec.push(6 $x);
            )*
          7 temp_vec
        }
    };
}
```

清单 19 - 28：`vec!` 宏定义的简化版本

> 注意：标准库中 `vec!` 宏的实际定义包括预先分配正确数量内存的代码。为了使示例更简单，我们在这里没有包含那段代码。

`#[macro_export]` 注释 \[1\] 表示，只要定义该宏的 crate 被引入作用域，这个宏就应该可用。没有这个注释，宏就不能被引入作用域。

然后我们使用 `macro_rules!` 和我们正在定义的宏的名称（不带感叹号）来开始宏定义 \[2\]。在这种情况下，名称是 `vec`，后面跟着表示宏定义主体的花括号。

`vec!` 主体中的结构类似于 `match` 表达式的结构。这里我们有一个带有模式 `( $( $x:expr ),* )` 的分支，后面跟着 `=>` 和与这个模式相关联的代码块 \[3\]。如果模式匹配，相关联的代码块就会被发出。鉴于这是这个宏中唯一的模式，所以只有一种有效的匹配方式；任何其他模式都会导致错误。更复杂的宏会有多个分支。

宏定义中的有效模式语法与第 18 章介绍的模式语法不同，因为宏模式是与 Rust 代码结构而不是值进行匹配。让我们逐步分析清单 19 - 28 中的模式部分是什么意思；有关完整的宏模式语法，请参阅 Rust 参考文档 *https://doc.rust-lang.org/reference/macros-by-example.html*。

首先，我们使用一组括号来包围整个模式。我们使用美元符号（`$`）在宏系统中声明一个变量，该变量将包含与模式匹配的 Rust 代码。美元符号清楚地表明这是一个宏变量，而不是普通的 Rust 变量。接下来是一组括号，它捕获与括号内模式匹配的值，以便在替换代码中使用。在 `$()` 内部是 `$x:expr`，它匹配任何 Rust 表达式，并将该表达式命名为 `$x`。

紧跟在 `$()` 后面的逗号表示在与 `$()` 中的代码匹配的代码之后，可能会出现一个字面逗号分隔符。`*` 表示该模式匹配零个或多个在 `*` 之前的任何内容。

当我们使用 `vec![1, 2, 3];` 调用这个宏时，`$x` 模式会与三个表达式 `1`、`2` 和 `3` 匹配三次。

现在让我们看看与这个分支相关联的代码主体中的模式：在 `$()*` 内的 `temp_vec.push()` \[5\] 在 \[4\] 和 \[7\] 处，会根据模式匹配的次数，为与模式中 `$()` 匹配的每个部分零次或多次生成。`$x` \[6\] 会被替换为每个匹配的表达式。当我们使用 `vec![1, 2, 3];` 调用这个宏时，替换这个宏调用生成的代码将如下所示：

    {
        let mut temp_vec = Vec::new();
        temp_vec.push(1);
        temp_vec.push(2);
        temp_vec.push(3);
        temp_vec
    }

我们已经定义了一个宏，它可以接受任意数量、任意类型的参数，并可以生成代码来创建一个包含指定元素的向量。

要了解更多关于如何编写宏的知识，请查阅在线文档或其他资源，例如由 Daniel Keep 发起并由 Lukas Wirth 继续维护的 *https://veykril.github.io/tlborm* 上的《Rust 宏小手册》。

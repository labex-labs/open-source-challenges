# 读取向量中的元素

有两种方法可以引用存储在向量中的值：通过索引或使用 `get` 方法。在以下示例中，为了更清晰，我们标注了这些函数返回值的类型。

清单 8-4 展示了使用索引语法和 `get` 方法这两种访问向量中值的方式。

```rust
let v = vec![1, 2, 3, 4, 5];

1 let third: &i32 = &v[2];
println!("The third element is {third}");

2 let third: Option<&i32> = v.get(2);
match third  {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}
```

清单 8-4：使用索引语法和 `get` 方法访问向量中的元素

这里需要注意一些细节。我们使用索引值 `2` 来获取第三个元素 \[1\]，因为向量是从 0 开始编号索引的。使用 `&` 和 `[]` 可以获取索引值处元素的引用。当我们将索引作为参数传递给 `get` 方法时 \[2\]，会得到一个 `Option<&T>`，我们可以使用 `match` 来处理它。

Rust 提供这两种引用元素的方式，以便你可以选择当尝试使用超出现有元素范围的索引值时程序的行为。例如，让我们看看当我们有一个包含五个元素的向量，然后尝试使用每种技术访问索引为 100 的元素时会发生什么，如清单 8-5 所示。

```rust
let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &v[100];
let does_not_exist = v.get(100);
```

清单 8-5：尝试访问包含五个元素的向量中索引为 100 的元素

当我们运行这段代码时，第一个使用 `[]` 方法的操作会导致程序恐慌，因为它引用了一个不存在的元素。当试图访问超出向量末尾的元素时，如果希望程序崩溃，这种方法是最合适的。

当 `get` 方法接收到一个超出向量范围的索引时，它会返回 `None` 而不会恐慌。如果在正常情况下偶尔会发生访问超出向量范围的元素的情况，你可以使用这种方法。然后你的代码可以有逻辑来处理 `Some(&element)` 或 `None` 的情况，正如第 6 章所讨论的。例如，索引可能来自用户输入的数字。如果他们不小心输入了一个太大的数字，程序得到一个 `None` 值，你可以告诉用户当前向量中有多少个元素，并给他们另一次机会输入一个有效的值。这比因为一个拼写错误而导致程序崩溃要更友好！

当程序有一个有效的引用时，借用检查器会强制执行所有权和借用规则（在第 4 章介绍），以确保这个引用以及任何其他对向量内容的引用保持有效。回想一下那个规则：在同一作用域内不能同时有可变引用和不可变引用。这个规则在清单 8-6 中适用，在那里我们对向量中的第一个元素持有一个不可变引用，然后试图在末尾添加一个元素。如果我们在函数后面还试图引用那个元素，这个程序将无法工作。

```rust
let mut v = vec![1, 2, 3, 4, 5];

let first = &v[0];

v.push(6);

println!("The first element is: {first}");
```

清单 8-6：在持有对一个元素的引用时尝试向向量中添加元素

编译这段代码会导致如下错误：

```bash
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as
immutable
 --> src/main.rs:6:5
  |
4 |     let first = &v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!("The first element is: {first}");
  |                                      ----- immutable borrow later used here
```

清单 8-6 中的代码看起来似乎应该能工作：为什么对第一个元素的引用会关心向量末尾的变化呢？这个错误是由于向量的工作方式导致的：因为向量在内存中是将值相邻存放的，如果没有足够的空间将所有元素相邻存放在向量当前存储的位置，那么在向量末尾添加一个新元素可能需要分配新的内存并将旧元素复制到新空间。在这种情况下，对第一个元素的引用可能会指向已释放的内存。借用规则可以防止程序陷入这种情况。

> 注意：有关 `Vec<T>` 类型的更多实现细节，请参阅 *https://doc.rust-lang.org/nomicon/vec/vec.html* 上的「The Rustonomicon」。

# 使用枚举存储多种类型

向量只能存储相同类型的值。这可能会带来不便；在某些用例中，确实需要存储不同类型的项的列表。幸运的是，枚举的变体是在同一个枚举类型下定义的，所以当我们需要一种类型来表示不同类型的元素时，可以定义并使用枚举！

例如，假设我们要从电子表格的一行中获取值，其中该行的某些列包含整数，某些列包含浮点数，还有一些列包含字符串。我们可以定义一个枚举，其变体将持有不同的值类型，并且所有枚举变体都将被视为相同的类型：即枚举的类型。然后我们可以创建一个向量来持有该枚举，从而最终持有不同的类型。我们在清单 8-9 中演示了这一点。

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

清单 8-9：定义一个枚举以在一个向量中存储不同类型的值

Rust 需要在编译时知道向量中将会有哪些类型，以便确切知道在堆上需要多少内存来存储每个元素。我们还必须明确这个向量中允许哪些类型。如果 Rust 允许向量持有任何类型，那么可能会有一个或多个类型在对向量元素执行操作时导致错误。正如第 6 章所讨论的，使用枚举加 `match` 表达式意味着 Rust 将在编译时确保处理每一种可能的情况。

如果你不知道程序在运行时要存储在向量中的所有可能类型，枚举技术就不起作用。相反，你可以使用特征对象，我们将在第 17 章介绍。

既然我们已经讨论了一些使用向量的最常见方法，一定要查看标准库为 `Vec<T>` 定义的所有许多有用方法的 API 文档。例如，除了 `push` 方法外，`pop` 方法会移除并返回最后一个元素。

# 读取参数值

为了让 `minigrep` 能够读取我们传递给它的命令行参数的值，我们需要使用 Rust 标准库中提供的 `std::env::args` 函数。这个函数返回一个传递给 `minigrep` 的命令行参数的迭代器。我们将在第 13 章全面介绍迭代器。目前，关于迭代器你只需要了解两个细节：迭代器会生成一系列值，并且我们可以在迭代器上调用 `collect` 方法，将其转换为一个集合，比如一个向量，该集合包含迭代器生成的所有元素。

清单 12-1 中的代码允许你的 `minigrep` 程序读取传递给它的任何命令行参数，然后将这些值收集到一个向量中。

文件名：`src/main.rs`

```rust
use std::env;

fn main() {
    let args: Vec<String> = env::args().collect();
    dbg!(args);
}
```

清单 12-1：将命令行参数收集到向量中并打印它们

首先，我们使用 `use` 语句将 `std::env` 模块引入作用域，这样我们就可以使用它的 `args` 函数。注意，`std::env::args` 函数嵌套在两级模块中。正如我们在第 7 章讨论的，在所需函数嵌套在多个模块中的情况下，我们选择引入父模块而不是函数。这样做，我们可以轻松地使用 `std::env` 中的其他函数。这也比添加 `use std::env::args` 然后只使用 `args` 调用函数更清晰，因为 `args` 很容易被误认为是当前模块中定义的函数。

> **`args` 函数与无效 Unicode**
>
> 注意，如果任何参数包含无效的 Unicode，`std::env::args` 将导致程序恐慌。如果你的程序需要接受包含无效 Unicode 的参数，请使用 `std::env::args_os` 代替。该函数返回一个生成 `OsString` 值而不是 `String` 值的迭代器。为了简单起见，我们在这里选择使用 `std::env::args`，因为 `OsString` 值在不同平台上有所不同，并且比 `String` 值更难处理。

在 `main` 函数的第一行，我们调用 `env::args`，并立即使用 `collect` 将迭代器转换为一个包含迭代器生成的所有值的向量。我们可以使用 `collect` 函数创建多种类型的集合，所以我们显式地为 `args` 的类型添加注释，以指定我们想要一个字符串向量。虽然在 Rust 中你很少需要注释类型，但 `collect` 是一个你经常需要注释类型的函数，因为 Rust 无法推断出你想要的集合类型。

最后，我们使用调试宏打印向量。让我们先尝试在不传递参数的情况下运行代码，然后再传递两个参数运行：

```bash
$ cargo run
--snip--
[src/main.rs:5] args = [
"target/debug/minigrep",
]
$ cargo run -- needle haystack
--snip--
[src/main.rs:5] args = [
"target/debug/minigrep",
"needle",
"haystack",
]
```

注意向量中的第一个值是 `"target/debug/minigrep"`，这是我们二进制文件的名称。这与 C 语言中参数列表的行为相匹配，让程序在执行时可以使用调用它们的名称。在你想要在消息中打印程序名称或者根据用于调用程序的命令行别名来改变程序行为时，能够访问程序名称通常很方便。但就本章而言，我们将忽略它，只保存我们需要的两个参数。

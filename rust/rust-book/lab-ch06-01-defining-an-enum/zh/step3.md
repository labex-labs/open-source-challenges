# Option 枚举及其相对于空值的优势

本节将探讨 `Option` 的一个案例研究，它是标准库定义的另一个枚举。`Option` 类型编码了一种非常常见的情况：一个值可能存在，也可能不存在。

例如，如果你请求包含多个元素的列表中的第一个元素，你会得到一个值。如果你请求空列表中的第一个元素，你将得不到任何值。用类型系统来表达这个概念意味着编译器可以检查你是否处理了所有应该处理的情况；这种功能可以防止在其他编程语言中极为常见的错误。

编程语言设计通常会考虑要包含哪些特性，但你排除的特性也很重要。Rust 没有许多其他语言所具有的空值特性。_空值_ 是一个表示那里没有值的值。在有空值的语言中，变量总是可以处于两种状态之一：空值或非空值。

在 2009 年的演讲《空引用：十亿美元的错误》中，空值的发明者托尼·霍尔（Tony Hoare）是这样说的：

> 我称它为我十亿美元的错误。当时，我正在为一种面向对象语言设计第一个全面的引用类型系统。我的目标是确保所有引用的使用都绝对安全，由编译器自动进行检查。但我忍不住诱惑加入了一个空引用，仅仅是因为它很容易实现。这导致了无数的错误、漏洞和系统崩溃，在过去的四十年里，这些可能已经造成了十亿美元的痛苦和损失。空值的问题在于，如果你试图将一个空值用作非空值，你会得到某种错误。因为这种空值或非空值的属性无处不在，所以极容易犯这种错误。

然而，空值试图表达的概念仍然是有用的：空值是一个由于某种原因当前无效或不存在的值。

问题并不真正在于这个概念，而在于具体的实现。因此，Rust 没有空值，但它有一个枚举，可以编码值存在或不存在的概念。这个枚举是 `Option<T>`，标准库将其定义如下：

```rust
enum Option<T> {
    None,
    Some(T),
}
```

`Option<T>` 枚举非常有用，甚至包含在标准库 prelude 中；你不需要显式地将其引入作用域。它的变体也包含在 prelude 中：你可以直接使用 `Some` 和 `None`，而无需 `Option::` 前缀。`Option<T>` 枚举仍然只是一个普通的枚举，`Some(T)` 和 `None` 仍然是 `Option<T>` 类型的变体。

`<T>` 语法是 Rust 中一个我们尚未讨论过的特性。它是一个泛型类型参数，我们将在第 10 章更详细地介绍泛型。目前，你只需要知道 `<T>` 意味着 `Option` 枚举的 `Some` 变体可以持有任何类型的一块数据，并且每个用于替换 `T` 的具体类型都会使整个 `Option<T>` 类型成为不同的类型。以下是一些使用 `Option` 值来持有数字类型和字符串类型的示例：

```rust
let some_number = Some(5);
let some_char = Some('e');

let absent_number: Option<i32> = None;
```

`some_number` 的类型是 `Option<i32>`。`some_char` 的类型是 `Option<char>`，这是一个不同的类型。Rust 可以推断这些类型，因为我们在 `Some` 变体中指定了一个值。对于 `absent_number`，Rust 要求我们注释整个 `Option` 类型：编译器仅通过查看一个 `None` 值无法推断出相应 `Some` 变体将持有的类型。在这里，我们告诉 Rust，我们希望 `absent_number` 是 `Option<i32>` 类型。

当我们有一个 `Some` 值时，我们知道有一个值存在，并且该值保存在 `Some` 中。当我们有一个 `None` 值时，在某种意义上它与空值的含义相同：我们没有一个有效的值。那么为什么使用 `Option<T>` 比使用空值更好呢？

简而言之，因为 `Option<T>` 和 `T`（其中 `T` 可以是任何类型）是不同的类型，编译器不会让我们将 `Option<T>` 值当作肯定是有效的值来使用。例如，这段代码不会编译，因为它试图将一个 `i8` 与一个 `Option<i8>` 相加：

```rust
let x: i8 = 5;
let y: Option<i8> = Some(5);

let sum = x + y;
```

如果我们运行这段代码，我们会得到如下错误消息：

```bash
error[E0277]: cannot add `Option<i8>` to `i8`
 --> src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + Option<i8>`
  |
  = help: the trait `Add<Option<i8>>` is not implemented for `i8`
```

很严重！实际上，这个错误消息意味着 Rust 不知道如何将一个 `i8` 和一个 `Option<i8>` 相加，因为它们是不同的类型。在 Rust 中，当我们有一个像 `i8` 这样类型的值时，编译器会确保我们始终有一个有效的值。在使用该值之前，我们可以放心地继续，而不必检查是否为空值。只有当我们有一个 `Option<i8>`（或我们正在处理的任何类型的值）时，我们才需要担心可能没有值，并且编译器会确保我们在使用该值之前处理这种情况。

换句话说，在对 `Option<T>` 执行 `T` 操作之前，你必须将其转换为 `T`。一般来说，这有助于捕获与空值最常见的问题之一：假设某个东西不为空而实际上它为空。

消除错误地假设非空值的风险有助于你对代码更有信心。为了拥有一个可能为空的值，你必须通过将该值的类型设为 `Option<T>` 来明确选择。然后，当你使用该值时，你需要明确处理该值为空的情况。在任何值的类型不是 `Option<T>` 的地方，你 _可以_ 安全地假设该值不为空。这是 Rust 的一个有意设计决策，以限制空值的普遍性并提高 Rust 代码的安全性。

那么，当你有一个 `Option<T>` 类型的值时，如何从 `Some` 变体中获取 `T` 值以便使用该值呢？`Option<T>` 枚举有大量在各种情况下都很有用的方法；你可以在其文档中查看它们。熟悉 `Option<T>` 上的方法在你学习 Rust 的过程中会非常有用。

一般来说，为了使用 `Option<T>` 值，你需要编写能够处理每个变体的代码。你需要一些仅在你有 `Some(T)` 值时才运行的代码，并且这段代码可以使用内部的 `T`。你还需要一些仅在你有 `None` 值时才运行的代码，并且那段代码没有可用的 `T` 值。`match` 表达式是一种控制流结构，当与枚举一起使用时，它就可以做到这一点：它会根据它所拥有的枚举变体运行不同的代码，并且那段代码可以使用匹配值内部的数据。

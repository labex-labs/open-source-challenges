# 与 `Option<T>` 进行匹配

在上一节中，当使用 `Option<T>` 时，我们想从 `Some` 情况中获取内部的 `T` 值；我们也可以像处理 `Coin` 枚举那样，使用 `match` 来处理 `Option<T>`！这里不是比较硬币，而是比较 `Option<T>` 的变体，但 `match` 表达式的工作方式是一样的。

假设我们想编写一个函数，它接受一个 `Option<i32>`，如果其中有值，就对该值加 1。如果其中没有值，函数应该返回 `None` 值，并且不尝试执行任何操作。

多亏了 `match`，这个函数很容易编写，如下所示，如清单 6-5 所示。

```rust
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
      1 None => None,
      2 Some(i) => Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five); 3
let none = plus_one(None); 4
```

清单 6-5：一个对 `Option<i32>` 使用 `match` 表达式的函数

让我们更详细地研究一下 `plus_one` 的第一次执行。当我们调用 `plus_one(five)` \[3\] 时，`plus_one` 函数体中的变量 `x` 将具有值 `Some(5)`。然后我们将其与每个匹配分支进行比较：

```rust
None => None,
```

`Some(5)` 值与模式 `None` 不匹配 \[1\]，所以我们继续到下一个分支：

```rust
Some(i) => Some(i + 1),
```

`Some(5)` 与 `Some(i)` 匹配吗 \[2\]？是的，匹配！我们有相同的变体。`i` 绑定到 `Some` 中包含的值，所以 `i` 取值为 `5`。然后执行匹配分支中的代码，所以我们将 `i` 的值加 1，并创建一个新的 `Some` 值，其中包含我们的总和 `6`。

现在让我们考虑清单 6-5 中 `plus_one` 的第二次调用，其中 `x` 是 `None` \[4\]。我们进入 `match` 并与第一个分支进行比较 \[1\]。

它匹配！没有值可加，所以程序停止并返回 `=>` 右侧的 `None` 值。因为第一个分支匹配，所以不会比较其他分支。

在许多情况下，将 `match` 和枚举结合使用很有用。你会在 Rust 代码中经常看到这种模式：对枚举进行 `match`，将一个变量绑定到内部的数据，然后根据它执行代码。一开始可能有点棘手，但一旦你习惯了，你会希望所有语言都有它。它一直是用户的最爱。

# 产生其他迭代器的方法

「迭代器适配器」是在 `Iterator` trait 上定义的方法，它们不会消耗迭代器。相反，它们通过改变原始迭代器的某些方面来产生不同的迭代器。

清单 13-14 展示了调用迭代器适配器方法 `map` 的示例，该方法在遍历项目时会对每个项目调用一个闭包。`map` 方法返回一个新的迭代器，该迭代器产生修改后的项目。这里的闭包创建了一个新的迭代器，其中向量中的每个项目都会增加 1。

文件名：`src/main.rs`

```rust
let v1: Vec<i32> = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
```

清单 13-14：调用迭代器适配器 `map` 来创建一个新的迭代器

然而，这段代码会产生一个警告：

    warning: unused `Map` that must be used
     --> src/main.rs:4:5
      |
    4 |     v1.iter().map(|x| x + 1);
      |     ^^^^^^^^^^^^^^^^^^^^^^^^^
      |
      = note: `#[warn(unused_must_use)]` on by default
      = note: iterators are lazy and do nothing unless consumed

清单 13-14 中的代码没有做任何事情；我们指定的闭包从未被调用。这个警告提醒了我们原因：迭代器适配器是惰性的，我们在这里需要消耗迭代器。

为了修复这个警告并消耗迭代器，我们将使用 `collect` 方法，我们在清单 12-1 中对 `env::args` 使用过这个方法。这个方法会消耗迭代器，并将结果值收集到一个集合数据类型中。

在清单 13-15 中，我们将调用 `map` 返回的迭代器进行迭代的结果收集到一个向量中。这个向量最终将包含原始向量中的每个项目，每个项目都增加了 1。

文件名：`src/main.rs`

```rust
let v1: Vec<i32> = vec![1, 2, 3];

let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
```

清单 13-15：调用 `map` 方法创建一个新的迭代器，然后调用 `collect` 方法消耗新的迭代器并创建一个向量

因为 `map` 接受一个闭包，所以我们可以指定对每个项目要执行的任何操作。这是闭包如何让你在重用 `Iterator` trait 提供的迭代行为的同时自定义某些行为的一个很好的例子。

你可以链式调用多个迭代器适配器，以一种可读的方式执行复杂的操作。但是因为所有迭代器都是惰性的，所以你必须调用其中一个消耗适配器方法才能从对迭代器适配器的调用中获得结果。

# 使用迭代器处理一系列项目

迭代器模式允许你依次对一系列项目执行某些任务。迭代器负责遍历每个项目的逻辑，并确定序列何时结束。当你使用迭代器时，无需自己重新实现该逻辑。

在 Rust 中，迭代器是「惰性的」，这意味着在你调用消耗迭代器的方法将其用完之前，它们不会产生任何效果。例如，清单 13-10 中的代码通过调用 `Vec<T>` 上定义的 `iter` 方法，创建了一个针对向量 `v1` 中项目的迭代器。这段代码本身并没有做任何有用的事情。

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
```

清单 13-10：创建一个迭代器

迭代器存储在 `v1_iter` 变量中。一旦我们创建了一个迭代器，就可以用多种方式使用它。在清单 3-5 中，我们使用 `for` 循环遍历数组，以便对其每个项目执行一些代码。在底层，这隐式地创建并消耗了一个迭代器，但到目前为止我们一直没有详细说明它具体是如何工作的。

在清单 13-11 的示例中，我们将迭代器的创建与在 `for` 循环中对迭代器的使用分开。当使用 `v1_iter` 中的迭代器调用 `for` 循环时，迭代器中的每个元素会在循环的一次迭代中被使用，从而打印出每个值。

```rust
let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!("Got: {val}");
}
```

清单 13-11：在 `for` 循环中使用迭代器

在那些标准库中没有提供迭代器的语言中，你可能会通过从索引 0 开始一个变量，使用该变量索引到向量中获取一个值，并在循环中递增变量值，直到它达到向量中项目的总数，来编写相同的功能。

迭代器为你处理所有这些逻辑，减少了你可能会搞乱的重复代码。迭代器为你提供了更大的灵活性，可以将相同的逻辑用于许多不同类型的序列，而不仅仅是像向量这样可以通过索引访问的数据结构。让我们来看看迭代器是如何做到这一点的。

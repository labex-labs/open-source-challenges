# String 类型

为了阐释所有权规则，我们需要一种比“数据类型”一章中所涵盖的类型更复杂的数据类型。之前涵盖的类型具有已知的大小，可以存储在栈上，并在其作用域结束时从栈上弹出，并且如果代码的其他部分需要在不同作用域中使用相同的值，可以快速且简单地进行复制以创建一个新的独立实例。但我们想要研究存储在堆上的数据，并探索 Rust 如何知道何时清理这些数据，而 `String` 类型就是一个很好的例子。

我们将专注于 `String` 中与所有权相关的部分。这些方面也适用于其他复杂数据类型，无论它们是由标准库提供还是由你创建。我们将在第 8 章更深入地讨论 `String`。

我们已经见过字符串字面量，其中字符串值被硬编码到我们的程序中。字符串字面量很方便，但它们并不适用于我们可能想要使用文本的每种情况。一个原因是它们是不可变的。另一个原因是，在编写代码时，并非每个字符串值都是已知的：例如，如果我们想要获取用户输入并存储它该怎么办？对于这些情况，Rust 有第二种字符串类型，即 `String`。这种类型管理在堆上分配的数据，因此能够存储我们在编译时未知数量的文本。你可以使用 `from` 函数从字符串字面量创建一个 `String`，如下所示：

```rust
let s = String::from("hello");
```

双冒号 `::` 运算符允许我们将这个特定的 `from` 函数置于 `String` 类型的命名空间下，而不是使用类似 `string_from` 这样的名称。我们将在“方法语法”中更详细地讨论这种语法，以及在“模块树中引用项的路径”中讨论使用模块进行命名空间时。

这种字符串 **可以** 被修改：

```rust
let mut s = String::from("hello");

s.push_str(", world!"); // push_str() 将一个字面量追加到一个 String

println!("{s}"); // 这将打印 `hello, world!`
```

那么，这里的区别是什么呢？为什么 `String` 可以被修改而字面量却不能呢？区别在于这两种类型处理内存的方式。

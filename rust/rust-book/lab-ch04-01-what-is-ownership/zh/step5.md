# 内存与分配

对于字符串字面量，我们在编译时就知道其内容，所以文本会直接被硬编码到最终的可执行文件中。这就是字符串字面量快速且高效的原因。但这些特性仅源于字符串字面量的不可变性。不幸的是，对于每一段在编译时大小未知且在程序运行时大小可能改变的文本，我们无法将一块内存放入二进制文件中。

对于 `String` 类型，为了支持可变的、可增长的文本，我们需要在堆上分配一块在编译时未知大小的内存来存储内容。这意味着：

- 必须在运行时从内存分配器请求内存。
- 当我们用完 `String` 后，需要有一种方法将这块内存归还给分配器。

第一部分由我们完成：当我们调用 `String::from` 时，其实现会请求它所需的内存。这在编程语言中几乎是通用的。

然而，第二部分则有所不同。在具有 **垃圾回收器（GC）** 的语言中，垃圾回收器会跟踪并清理不再使用的内存，我们无需对此操心。在大多数没有垃圾回收器的语言中，我们有责任确定内存何时不再被使用，并调用代码来显式释放它，就像我们请求内存时所做的那样。从历史上看，正确地做到这一点一直是一个困难的编程问题。如果我们忘记了，就会浪费内存。如果我们做得太早，就会有一个无效的变量。如果我们做了两次，那也是一个错误。我们需要将一个 `allocate` 与一个 `free` 精确配对。

Rust 采取了不同的方式：一旦拥有内存的变量超出作用域，内存就会自动被归还。下面是清单 4-1 中作用域示例的一个版本，这里使用 `String` 而不是字符串字面量：

    {
        let s = String::from("hello"); // 从这一点起 s 有效

        // 对 s 进行一些操作
    }                                  // 这个作用域现在结束了，s 不再有效

有一个自然的时机可以将我们的 `String` 所需的内存归还给分配器：当 `s` 超出作用域时。当一个变量超出作用域时，Rust 会为我们调用一个特殊的函数。这个函数叫做 `drop`，`String` 的作者可以在这个函数中编写归还内存的代码。Rust 会在右花括号处自动调用 `drop`。

> 注意：在 C++ 中，在一个对象生命周期结束时释放资源的这种模式有时被称为 **资源获取即初始化（RAII）**。如果你使用过 RAII 模式，那么 Rust 中的 `drop` 函数对你来说会很熟悉。

这种模式对 Rust 代码的编写方式有深远的影响。现在看起来可能很简单，但当我们想要让多个变量使用我们在堆上分配的数据时，在更复杂的情况下，代码的行为可能会出人意料。现在让我们来探讨其中的一些情况。

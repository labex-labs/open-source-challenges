# 什么是所有权？

**所有权** 是一组规则，用于管理 Rust 程序如何管理内存。所有程序在运行时都必须管理其使用计算机内存的方式。有些语言具有垃圾回收机制，在程序运行时会定期查找不再使用的内存；而在其他语言中，程序员必须显式地分配和释放内存。Rust 采用了第三种方法：通过所有权系统来管理内存，该系统有一组编译器会检查的规则。如果违反了任何一条规则，程序将无法编译。所有权的任何特性都不会在程序运行时降低其速度。

因为所有权对许多程序员来说是一个新概念，所以确实需要一些时间来适应。好消息是，你对 Rust 和所有权系统的规则越有经验，就会发现编写安全高效的代码就越自然。坚持下去！

当你理解了所有权，你就为理解使 Rust 独特的特性奠定了坚实的基础。在本章中，你将通过一些专注于非常常见的数据结构：字符串的示例来学习所有权。

> **栈和堆**
>
> 许多编程语言并不要求你经常考虑栈和堆。但在像 Rust 这样的系统编程语言中，一个值是在栈上还是在堆上会影响语言的行为方式，以及你为什么必须做出某些决定。本章后面会结合栈和堆来描述所有权的部分内容，所以这里先做一个简要的解释作为铺垫。
>
> 栈和堆都是你的代码在运行时可使用的内存部分，但它们的结构不同。栈按照获取值的顺序存储值，并以相反的顺序移除值。这被称为 **后进先出**。想象一叠盘子：当你添加更多盘子时，你把它们放在最上面，当你需要一个盘子时，你从最上面拿一个。从中间或底部添加或移除盘子就不太可行！添加数据称为 **压入栈**，移除数据称为 **弹出栈**。所有存储在栈上的数据必须有已知的、固定的大小。在编译时大小未知或可能改变大小的数据必须存储在堆上。
>
> 堆的组织性较差：当你在堆上放置数据时，你请求一定量的空间。内存分配器在堆中找到一个足够大的空位，将其标记为已使用，并返回一个 **指针**，即该位置的地址。这个过程称为 **在堆上分配**，有时简称为 **分配**（将值压入栈不被视为分配）。因为指向堆的指针是已知的、固定大小的，所以你可以将指针存储在栈上，但当你想要实际数据时，必须跟随指针。想象一下在餐厅就座。当你进入时，你说出你的团体人数，服务员会找到一个能容纳所有人的空桌子并带你过去。如果你的团体中有其他人来晚了，他们可以询问你坐在哪里来找到你。
>
> 压入栈比在堆上分配快，因为分配器不必搜索存储新数据的位置；那个位置总是在栈顶。相比之下，在堆上分配空间需要更多工作，因为分配器必须首先找到一个足够大的空间来容纳数据，然后进行簿记以准备下一次分配。
>
> 访问堆中的数据比访问栈中的数据慢，因为你必须跟随指针才能到达那里。现代处理器在内存中跳转越少就越快。继续这个比喻，想象餐厅里的一个服务员从许多桌子那里接单。在去下一张桌子之前先从一张桌子接完所有订单是最有效的。先从 A 桌接一个订单，然后从 B 桌接一个订单，再从 A 桌接一个订单，然后再从 B 桌接一个订单，这将是一个慢得多的过程。同样，处理器如果处理的数据彼此靠近（就像在栈上那样）而不是相距较远（就像在堆上那样），就能更好地完成工作。
>
> 当你的代码调用一个函数时，传递给函数的值（可能包括指向堆上数据的指针）和函数的局部变量会被压入栈。当函数结束时，这些值会从栈中弹出。
>
> 跟踪代码的哪些部分正在使用堆上的哪些数据，最小化堆上重复数据的数量，以及清理堆上未使用的数据以避免空间耗尽，这些都是所有权要解决的问题。一旦你理解了所有权，你就不需要经常考虑栈和堆了，但知道所有权的主要目的是管理堆数据可以帮助解释它为什么以这种方式工作。

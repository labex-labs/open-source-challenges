# 仅存储在栈上的数据：Copy

还有一个我们尚未讨论的细节。这段使用整数的代码（清单 4-2 展示了其中一部分）能够正常运行且有效：

```rust
let x = 5;
let y = x;

println!("x = {x}, y = {y}");
```

但这段代码似乎与我们刚刚学到的内容相矛盾：我们没有调用 `clone`，但 `x` 仍然有效，并且没有被移动到 `y` 中。

原因是像整数这样在编译时具有已知大小的类型完全存储在栈上，所以实际值的复制很快就能完成。这意味着在创建变量 `y` 之后，我们没有理由阻止 `x` 继续有效。换句话说，这里的深拷贝和浅拷贝没有区别，所以调用 `clone` 与普通的浅拷贝没有任何不同，我们可以省略它。

Rust 有一个特殊的标注，称为 `Copy` 特性，我们可以将其应用于存储在栈上的类型，整数就是这样的类型（我们将在第 10 章更多地讨论特性）。如果一个类型实现了 `Copy` 特性，那么使用它的变量不会被移动，而是会被简单地复制，这使得它们在赋值给另一个变量后仍然有效。

如果一个类型或其任何部分实现了 `Drop` 特性，Rust 不会允许我们为该类型标注 `Copy`。如果一个类型在值超出作用域时需要进行特殊处理，而我们为该类型添加了 `Copy` 标注，将会得到一个编译时错误。要了解如何为你的类型添加 `Copy` 标注以实现该特性，请参阅“可派生特性”。

那么，哪些类型实现了 `Copy` 特性呢？你可以查看给定类型的文档以确定，但一般来说，任何一组简单的标量值类型都可以实现 `Copy`，而任何需要分配内存或某种形式资源的类型都不能实现 `Copy`。以下是一些实现了 `Copy` 的类型：

- 所有整数类型，例如 `u32`。
- 布尔类型 `bool`，其值为 `true` 和 `false`。
- 所有浮点类型，例如 `f64`。
- 字符类型 `char`。
- 元组，如果它们只包含也实现了 `Copy` 的类型。例如，`(i32, i32)` 实现了 `Copy`，但 `(i32, String)` 没有。

# 解引用强制转换如何与可变性交互

与你使用 `Deref` 特性来重载不可变引用上的 `*` 运算符的方式类似，你可以使用 `DerefMut` 特性来重载可变引用上的 `*` 运算符。

当 Rust 在三种情况下找到类型和特性实现时，会进行解引用强制转换：

- 当 `T: Deref<Target=U>` 时，从 `&T` 转换为 `&U`
- 当 `T: DerefMut<Target=U>` 时，从 `&mut T` 转换为 `&mut U`
- 当 `T: Deref<Target=U>` 时，从 `&mut T` 转换为 `&U`

前两种情况是相同的，只是第二种情况实现了可变性。第一种情况表明，如果你有一个 `&T`，并且 `T` 实现了到某个类型 `U` 的 `Deref`，那么你可以透明地获得一个 `&U`。第二种情况表明，对于可变引用也会发生相同的解引用强制转换。

第三种情况更棘手：Rust 也会将可变引用强制转换为不可变引用。但反过来是**不可能的**：不可变引用永远不会强制转换为可变引用。由于借用规则，如果你有一个可变引用，那么该可变引用必须是对该数据的唯一引用（否则，程序将无法编译）。将一个可变引用转换为一个不可变引用永远不会违反借用规则。将一个不可变引用转换为一个可变引用将要求初始的不可变引用是对该数据的唯一不可变引用，但借用规则并不能保证这一点。因此，Rust 不能假设将不可变引用转换为可变引用是可能的。

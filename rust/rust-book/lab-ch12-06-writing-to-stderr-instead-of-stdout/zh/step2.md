# 检查错误信息的输出位置

首先，让我们观察一下 `minigrep` 打印的内容当前是如何写入标准输出的，包括那些我们希望写入标准错误的错误信息。我们将通过把标准输出流重定向到一个文件，同时故意制造一个错误来实现这一点。我们不会重定向标准错误流，所以任何发送到标准错误的内容将继续显示在屏幕上。

命令行程序应该将错误信息发送到标准错误流，这样即使我们将标准输出流重定向到一个文件，我们仍然可以在屏幕上看到错误信息。我们的程序目前表现不佳：我们即将看到它将错误信息输出保存到了一个文件中！

为了演示这种行为，我们将使用 `>` 和我们想要将标准输出流重定向到的文件路径 `output.txt` 来运行程序。我们不会传递任何参数，这应该会导致一个错误：

```bash
cargo run > output.txt
```

`>` 语法告诉 shell 将标准输出的内容写入 `output.txt` 而不是屏幕。我们没有看到预期的错误信息打印到屏幕上，这意味着它一定最终进入了文件。这是 `output.txt` 包含的内容：

```rust
Problem parsing arguments: not enough arguments
```

没错，我们的错误信息被打印到了标准输出。像这样的错误信息打印到标准错误会更有用，这样只有成功运行的数据才会最终进入文件。我们将改变这一点。

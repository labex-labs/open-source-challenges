# 作为类型系统和代码共享方式的继承

「继承」是一种机制，通过它一个对象可以从另一个对象的定义中继承元素，从而无需再次定义就能获得父对象的数据和行为。

如果一门语言必须具备继承才能被视为面向对象，那么 Rust 不是这样的语言。在不使用宏的情况下，无法定义一个继承父结构体字段和方法实现的结构体。

然而，如果你习惯在编程工具库中使用继承，那么在 Rust 中可以根据你最初使用继承的原因选择其他解决方案。

你选择继承主要有两个原因。一是为了代码复用：你可以为一种类型实现特定行为，而继承能让你将该实现复用于不同类型。在 Rust 代码中，你可以使用默认的 trait 方法实现以有限的方式做到这一点，就像我们在清单 10-14 中为 `Summary` trait 添加 `summarize` 方法的默认实现时那样。任何实现了 `Summary` trait 的类型都能直接使用 `summarize` 方法，无需额外代码。这类似于父类有一个方法的实现，继承的子类也有该方法的实现。当我们实现 `Summary` trait 时，也可以重写 `summarize` 方法的默认实现，这类似于子类重写从父类继承的方法的实现。

使用继承的另一个原因与类型系统有关：使子类型能够在与父类型相同的地方使用。这也被称为「多态性」，意味着如果多个对象共享某些特征，那么在运行时你可以用它们相互替换。

> **多态性**
>
> 对许多人来说，多态性与继承是同义词。但实际上它是一个更通用的概念，指的是可以处理多种类型数据的代码。对于继承来说，这些类型通常是子类。
>
> Rust 而是使用泛型来抽象不同的可能类型，并使用 trait 约束来对这些类型必须提供的内容施加限制。这有时被称为「有界参数多态性」。

最近，在许多编程语言中，继承作为一种编程设计解决方案已不再受欢迎，因为它常常存在共享过多不必要代码的风险。子类并不总是应该共享其父类的所有特征，但使用继承时它们会这样做。这可能会使程序的设计缺乏灵活性。它还引入了在子类上调用不合理方法或导致错误的可能性，因为这些方法并不适用于子类。此外，一些语言只允许单继承（即一个子类只能从一个类继承），这进一步限制了程序设计的灵活性。

出于这些原因，Rust 采用了不同的方法，即使用 trait 对象而不是继承。让我们看看 trait 对象如何在 Rust 中实现多态性。

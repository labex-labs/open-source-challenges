# 状态模式的权衡

我们已经展示了 Rust 能够实现面向对象的状态模式，以封装文章在每个状态下应具有的不同行为。`Post` 上的方法对各种行为一无所知。按照我们组织代码的方式，我们只需要在一个地方查看就能了解已发布文章的不同行为方式：`Published` 结构体上 `State` trait 的实现。

如果我们要创建一个不使用状态模式的替代实现，我们可能会在 `Post` 上的方法中，甚至在检查文章状态并在这些地方更改行为的 `main` 代码中使用 `match` 表达式。这意味着我们必须在几个地方查找才能理解文章处于已发布状态的所有影响！随着我们添加的状态越来越多，情况只会变得更糟：每个 `match` 表达式都需要另一个分支。

使用状态模式时，`Post` 方法以及我们使用 `Post` 的地方都不需要 `match` 表达式，并且要添加一个新状态，我们只需要添加一个新结构体并在该结构体上实现 trait 方法。

使用状态模式的实现很容易扩展以添加更多功能。为了了解维护使用状态模式的代码的简单性，请尝试以下一些建议：

- 添加一个 `reject` 方法，将文章的状态从“待审核”改回“草稿”。
- 在状态更改为“已发布”之前，需要调用两次 `approve`。
- 仅当文章处于“草稿”状态时，才允许用户添加文本内容。提示：让状态对象负责内容可能发生的变化，但不负责修改 `Post`。

状态模式的一个缺点是，由于状态实现了状态之间的转换，一些状态相互耦合。如果我们在“待审核”和“已发布”之间添加另一个状态，例如“已安排”，我们将不得不更改“待审核”中的代码以转换到“已安排”。如果“待审核”不需要随着新状态的添加而更改，工作量会更小，但这意味着要切换到另一种设计模式。

另一个缺点是我们重复了一些逻辑。为了消除一些重复，我们可能会尝试为 `State` trait 上的 `request_review` 和 `approve` 方法创建默认实现，返回 `self`。然而，这行不通：当将 `State` 用作 trait 对象时，trait 并不知道具体的 `self` 到底是什么，所以返回类型在编译时是未知的。

其他重复包括 `Post` 上 `request_review` 和 `approve` 方法的类似实现。这两个方法都委托给 `Option` 的 `state` 字段中的值上的相同方法的实现，并将 `state` 字段的新值设置为结果。如果我们在 `Post` 上有很多遵循此模式的方法，我们可能会考虑定义一个宏来消除重复（参见“宏”）。

通过完全按照为面向对象语言定义的方式实现状态模式，我们没有充分利用 Rust 的优势。让我们看看对 `blog` 包可以做哪些更改，以使无效状态和转换成为编译时错误。

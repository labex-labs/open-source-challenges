# trait 对象执行动态分派

回忆一下在“使用泛型的代码性能”中，我们关于编译器在对泛型使用 trait 边界时执行的单态化过程的讨论：编译器为我们用来代替泛型类型参数的每个具体类型生成函数和方法的非泛型实现。单态化产生的代码执行的是**静态分派**，即编译器在编译时就知道你正在调用哪个方法。这与**动态分派**相反，动态分派是指编译器在编译时无法确定你正在调用哪个方法。在动态分派的情况下，编译器生成的代码在运行时会确定要调用哪个方法。

当我们使用 trait 对象时，Rust 必须使用动态分派。编译器不知道所有可能与使用 trait 对象的代码一起使用的类型，所以它不知道要调用在哪个类型上实现的哪个方法。相反，在运行时，Rust 使用 trait 对象内部的指针来确定要调用哪个方法。这种查找会带来运行时开销，而静态分派不会有这种开销。动态分派还会阻止编译器选择内联方法的代码，这反过来又会阻止一些优化。然而，在清单 17-5 中编写的代码以及在清单 17-9 中能够支持的代码中，我们确实获得了额外的灵活性，所以这是一个需要权衡的问题。

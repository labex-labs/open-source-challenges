# 使用允许不同类型值的 trait 对象

在第 8 章中，我们提到了向量的一个局限性，即它们只能存储一种类型的元素。我们在清单 8-9 中创建了一个变通方法，在那里我们定义了一个 `SpreadsheetCell` 枚举，它有用于存储整数、浮点数和文本的变体。这意味着我们可以在每个单元格中存储不同类型的数据，并且仍然有一个表示一行单元格的向量。当我们可互换的项是一组固定的类型，并且在代码编译时我们就知道这些类型时，这是一个非常好的解决方案。

然而，有时我们希望库的用户能够扩展在特定情况下有效的类型集。为了展示我们如何实现这一点，我们将创建一个示例图形用户界面 (GUI) 工具，它遍历一组项的列表，并对每个项调用 `draw` 方法以将其绘制到屏幕上 —— 这是 GUI 工具的一种常见技术。我们将创建一个名为 `gui` 的库 crate，它包含 GUI 库的结构。这个 crate 可能会包含一些供人们使用的类型，比如 `Button` 或 `TextField`。此外，`gui` 的用户会希望创建他们自己的可绘制类型：例如，一个程序员可能会添加一个 `Image`，另一个程序员可能会添加一个 `SelectBox`。

对于这个示例，我们不会实现一个完整的 GUI 库，而是展示各个部分如何组合在一起。在编写库时，我们无法知道并定义其他程序员可能想要创建的所有类型。但我们确实知道 `gui` 需要跟踪许多不同类型的值，并且需要对每个这些不同类型的值调用 `draw` 方法。它不需要确切知道当我们调用 `draw` 方法时会发生什么，只需要知道该值有这个方法可供我们调用。

要在具有继承的语言中做到这一点，我们可能会定义一个名为 `Component` 的类，它有一个名为 `draw` 的方法。其他类，比如 `Button`、`Image` 和 `SelectBox`，将从 `Component` 继承，从而继承 `draw` 方法。它们可以各自重写 `draw` 方法来定义自己的自定义行为，但框架可以将所有这些类型视为 `Component` 实例，并对它们调用 `draw` 方法。但由于 Rust 没有继承，我们需要另一种方式来构建 `gui` 库，以允许用户用新类型扩展它。

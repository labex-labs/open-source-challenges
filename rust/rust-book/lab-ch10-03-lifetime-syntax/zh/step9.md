# 生命周期省略

你已经了解到每个引用都有一个生命周期，并且你需要为使用引用的函数或结构体指定生命周期参数。然而，我们在清单 4-9 中有一个函数（清单 10-25 中再次展示），它在没有生命周期标注的情况下也能编译通过。

文件名：`src/lib.rs`

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}
```

清单 10-25：我们在清单 4-9 中定义的一个函数，即使参数和返回类型都是引用，它也能在没有生命周期标注的情况下编译通过

这个函数在没有生命周期标注的情况下就能编译通过，原因是历史性的：在 Rust 的早期版本（1.0 之前），这段代码是无法编译的，因为每个引用都需要一个显式的生命周期。那时，函数签名会写成这样：

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

在编写了大量的 Rust 代码之后，Rust 团队发现 Rust 程序员在特定情况下会反复输入相同的生命周期标注。这些情况是可预测的，并且遵循一些确定的模式。开发者将这些模式编写到编译器的代码中，这样借用检查器就能在这些情况下推断出生命周期，而无需显式标注。

这段 Rust 的历史很重要，因为可能会出现更多确定的模式并被添加到编译器中。未来，可能需要更少的生命周期标注。

编写到 Rust 引用分析中的这些模式被称为**生命周期省略规则**。这些不是程序员需要遵循的规则；它们是编译器会考虑的一组特定情况，如果你的代码符合这些情况，你就不需要显式地编写生命周期。

省略规则并不能提供完全的推断。如果 Rust 确定性地应用了这些规则，但对于引用的生命周期仍然存在歧义，编译器不会猜测其余引用的生命周期应该是什么。编译器不会猜测，而是会给你一个错误，你可以通过添加生命周期标注来解决。

函数或方法参数上的生命周期被称为**输入生命周期**，返回值上的生命周期被称为**输出生命周期**。

当没有显式标注时，编译器使用三条规则来确定引用的生命周期。第一条规则适用于输入生命周期，第二条和第三条规则适用于输出生命周期。如果编译器应用完这三条规则后，仍然有一些引用的生命周期无法确定，编译器将会报错停止。这些规则适用于 `fn` 定义以及 `impl` 块。

第一条规则是，编译器为每个作为引用的参数分配一个生命周期参数。换句话说，一个有一个参数的函数会得到一个生命周期参数：`fn foo<'a>(x: &'a i32)`；一个有两个参数的函数会得到两个单独的生命周期参数：`fn foo<'a, 'b>(x: &'a i32, y: &'b i32)`；以此类推。

第二条规则是，如果恰好有一个输入生命周期参数，那么这个生命周期会被分配给所有输出生命周期参数：`fn foo<'a>(x: &'a i32) -> &'a i32`。

第三条规则是，如果有多个输入生命周期参数，但其中一个是 `&self` 或 `&mut self`，因为这是一个方法，那么 `self` 的生命周期会被分配给所有输出生命周期参数。这条规则使得方法的读写更加友好，因为需要的符号更少。

假设我们是编译器。我们将应用这些规则来确定清单 10-25 中 `first_word` 函数签名中引用的生命周期。签名一开始没有与引用相关联的任何生命周期：

```rust
fn first_word(s: &str) -> &str {
```

然后编译器应用第一条规则，该规则指定每个参数都有自己的生命周期。我们像往常一样将其称为 `'a`，所以现在签名是这样的：

```rust
fn first_word<'a>(s: &'a str) -> &str {
```

第二条规则适用，因为恰好有一个输入生命周期。第二条规则指定一个输入参数的生命周期会被分配给输出生命周期，所以现在签名是这样的：

```rust
fn first_word<'a>(s: &'a str) -> &'a str {
```

现在这个函数签名中的所有引用都有了生命周期，编译器可以继续进行分析，而无需程序员在这个函数签名中注释生命周期。

让我们看另一个例子，这次使用我们在清单 10-20 中开始处理时没有生命周期参数的 `longest` 函数：

```rust
fn longest(x: &str, y: &str) -> &str {
```

让我们应用第一条规则：每个参数都有自己的生命周期。这次我们有两个参数而不是一个，所以我们有两个生命周期：

```rust
fn longest<'a, 'b>(x: &'a str, y: &'b str) -> &str {
```

你可以看到第二条规则不适用，因为有多个输入生命周期。第三条规则也不适用，因为 `longest` 是一个函数而不是一个方法，所以没有参数是 `self`。在应用完所有三条规则后，我们仍然没有确定返回类型的生命周期是什么。这就是为什么我们在尝试编译清单 10-20 中的代码时会得到一个错误：编译器应用了生命周期省略规则，但仍然无法确定签名中所有引用的生命周期。

因为第三条规则实际上只适用于方法签名，所以我们接下来将在那个上下文中查看生命周期，看看为什么第三条规则意味着我们通常不必在方法签名中注释生命周期。

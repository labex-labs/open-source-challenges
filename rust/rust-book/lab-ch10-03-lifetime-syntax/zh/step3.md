# 借用检查器

Rust 编译器有一个**借用检查器**，它会比较作用域以确定所有借用是否有效。清单 10-17 展示了与清单 10-16 相同的代码，但添加了注释以显示变量的生命周期。

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
```

清单 10-17：分别名为 `'a` 和 `'b` 的 `r` 和 `x` 的生命周期注释

在这里，我们用 `'a` 标注了 `r` 的生命周期，用 `'b` 标注了 `x` 的生命周期。如你所见，内部的 `'b` 块比外部的 `'a` 生命周期块小得多。在编译时，Rust 比较这两个生命周期的大小，发现 `r` 的生命周期是 `'a`，但它引用的内存生命周期是 `'b`。程序被拒绝，因为 `'b` 比 `'a` 短：引用的对象没有引用存活的时间长。

清单 10-18 修改了代码，使其没有悬空引用，并且可以无错误地编译。

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+
```

清单 10-18：一个有效的引用，因为数据的生命周期比引用长

在这里，`x` 的生命周期是 `'b`，在这种情况下它比 `'a` 大。这意味着 `r` 可以引用 `x`，因为 Rust 知道在 `x` 有效的时候，`r` 中的引用将始终有效。

既然你已经知道了引用的生命周期在哪里，以及 Rust 如何分析生命周期以确保引用始终有效，那么让我们在函数的上下文中探索参数和返回值的泛型生命周期。

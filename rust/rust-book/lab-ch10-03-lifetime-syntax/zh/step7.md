# 从生命周期的角度思考

你需要指定生命周期参数的方式取决于你的函数在做什么。例如，如果我们将 `longest` 函数的实现改为总是返回第一个参数而不是最长的字符串切片，那么我们就不需要为 `y` 参数指定生命周期。以下代码将编译通过：

文件名：`src/main.rs`

```rust
fn longest<'a>(x: &'a str, y: &str) -> &'a str {
    x
}
```

我们为参数 `x` 和返回类型指定了生命周期参数 `'a`，但没有为参数 `y` 指定，因为 `y` 的生命周期与 `x` 或返回值的生命周期没有任何关系。

当从函数返回一个引用时，返回类型的生命周期参数需要与其中一个参数的生命周期参数相匹配。如果返回的引用**不**指向其中一个参数，那么它必须指向在这个函数中创建的值。然而，这将是一个悬空引用，因为这个值将在函数结束时超出作用域。考虑一下 `longest` 函数的这个无法编译的尝试实现：

文件名：`src/main.rs`

```rust
fn longest<'a>(x: &str, y: &str) -> &'a str {
    let result = String::from("really long string");
    result.as_str()
}
```

在这里，即使我们为返回类型指定了生命周期参数 `'a`，这个实现也会编译失败，因为返回值的生命周期与参数的生命周期完全无关。这是我们得到的错误信息：

```bash
error[E0515]: cannot return reference to local variable `result`
  --> src/main.rs:11:5
   |
11 |     result.as_str()
   |     ^^^^^^^^^^^^^^^ returns a reference to data owned by the
current function
```

问题在于 `result` 在 `longest` 函数结束时超出作用域并被清理。我们还试图从函数中返回对 `result` 的引用。我们无法指定任何生命周期参数来改变这个悬空引用，并且 Rust 不允许我们创建悬空引用。在这种情况下，最好的解决办法是返回一个拥有所有权的数据类型而不是引用，这样调用函数就负责清理这个值。

最终，生命周期语法是关于连接函数的各种参数和返回值的生命周期。一旦它们连接起来，Rust 就有足够的信息来允许内存安全的操作，并禁止创建悬空指针或以其他方式违反内存安全的操作。

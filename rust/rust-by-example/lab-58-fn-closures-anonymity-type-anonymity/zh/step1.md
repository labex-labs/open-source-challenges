# 类型匿名性

闭包能够简洁地捕获外部作用域中的变量。这会带来什么影响吗？当然有。请注意，将闭包用作函数参数时需要使用[泛型]，这是由闭包的定义方式决定的：

```rust
// `F` 必须是泛型的。
fn apply<F>(f: F) where
    F: FnOnce() {
    f();
}
```

定义闭包时，编译器会隐式创建一个新的匿名结构体，用于存储捕获的变量，同时通过 `Fn`、`FnMut` 或 `FnOnce` 这些特性之一为这个未知类型实现功能。这个类型会赋给存储的变量，直到调用时使用。

由于这个新类型是未知的，函数中的任何使用都需要泛型。然而，无界类型参数 `<T>` 仍然会产生歧义，是不允许的。因此，通过 `Fn`、`FnMut` 或 `FnOnce` 这些特性之一（闭包实现了其中之一）进行约束，就足以指定其类型。

```rust
// 对于不接受输入且不返回任何值的闭包（这正是 `print` 所需要的），`F` 必须实现 `Fn`。
fn apply<F>(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // 将 `x` 捕获到一个匿名类型中，并为其实现 `Fn`。将其存储在 `print` 中。
    let print = || println!("{}", x);

    apply(print);
}
```

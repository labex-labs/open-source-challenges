# macro_rules!

Rust 提供了一个强大的宏系统，支持元编程。正如你在前面章节中看到的，宏看起来像函数，只是它们的名字以惊叹号 `!` 结尾。不过，宏并不会生成函数调用，而是会被扩展为与程序其他部分一起编译的源代码。然而，与 C 和其他语言中的宏不同，Rust 宏会被扩展为抽象语法树，而不是字符串预处理，所以你不会遇到意外的优先级错误。

宏是使用 `macro_rules!` 宏创建的。

```rust
// 这是一个名为 `say_hello` 的简单宏。
macro_rules! say_hello {
    // `()` 表示该宏不接受参数。
    () => {
        // 宏会扩展为此代码块的内容。
        println!("Hello!")
    };
}

fn main() {
    // 此调用会扩展为 `println!("Hello")`
    say_hello!()
}
```

那么宏为什么有用呢？

1.  避免重复代码。在很多情况下，你可能在多个地方需要类似的功能，但类型不同。通常，编写宏是避免重复代码的有效方法。（稍后会详细介绍）

2.  特定领域语言。宏允许你为特定目的定义特殊语法。（稍后会详细介绍）

3.  可变参数接口。有时你想定义一个接受可变数量参数的接口。例如 `println!`，它可以根据格式字符串接受任意数量的参数。（稍后会详细介绍）
